import { defineDocumentType, makeSource } from 'contentlayer2/source-files';
import fs from 'fs';
import GithubSlugger from 'github-slugger';
import { h } from 'hastscript';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypePrettyCode from 'rehype-pretty-code';
import rehypeSlug from 'rehype-slug';
import { codeImport } from 'remark-code-import';
import remarkGfm from 'remark-gfm';
import { u } from 'unist-builder';
import { visit } from 'unist-util-visit';
import { Store } from './__store__/index.mjs';
import { getPTOptions, getStyleOptions, getTokenOptions } from './lib/utils/getComponentOptions';

export const Docs = defineDocumentType(() => ({
    name: 'Docs',
    filePathPattern: '**/**/*.mdx',
    contentType: 'mdx',
    fields: {
        title: { type: 'string', required: true },
        description: { type: 'string', required: false },
        component: { type: 'string', required: false },
        styles: { type: 'list', of: { type: 'string' }, required: false },
        tokens: { type: 'list', of: { type: 'string' }, required: false },
        pts: { type: 'list', of: { type: 'string' }, required: false },
        autoGenerated: { type: 'boolean', required: false },
        lastUpdated: { type: 'date', required: false },
        hideTabAndToc: { type: 'boolean', required: false, default: false }
    },
    computedFields: {
        slug: {
            type: 'string',
            resolve: (doc) => {
                return `/docs/${doc._raw.flattenedPath.includes('features') ? doc._raw.sourceFileDir : doc._raw.flattenedPath}`;
            }
        },
        componentSlug: {
            type: 'string',
            resolve: (doc) => {
                return `${doc._raw.flattenedPath.includes('features') ? doc._raw.sourceFileDir : doc._raw.flattenedPath}`;
            }
        },
        llm: {
            type: 'string',
            resolve: async (doc) => {
                let content = doc.body.raw;

                content = replaceComponentViewer(content);
                content = replaceApiTable(content);

                return content;
            }
        },
        toc: {
            type: 'list',
            of: { type: 'object' },
            resolve: async (doc) => {
                const regXHeader = /\n(?<flag>#{1,6})\s+(?<content>.+)/g;
                const slugger = new GithubSlugger();

                const headings = Array.from(doc.body.raw.matchAll(regXHeader)).map(({ groups }) => {
                    const flag = groups?.flag;
                    const content = groups?.content;

                    return {
                        level: flag.length,
                        text: content,
                        slug: content ? slugger.slug(content) : undefined
                    };
                });

                return headings;
            }
        }
    }
}));

export default makeSource({
    contentDirPath: './docs',
    documentTypes: [Docs],
    mdx: {
        remarkPlugins: [remarkGfm, codeImport],
        rehypePlugins: [
            rehypeSlug,
            () => (tree) => {
                visit(tree, (node) => {
                    if (node.name === 'DocComponentViewer') {
                        const name = getNodeAttributeByName(node, 'name')?.value;
                        const hideCode = getNodeAttributeByName(node, 'hideCode')?.value === 'true';

                        if (!name) {
                            return null;
                        }

                        let filePath;

                        if (name.includes(':')) {
                            const [component, demo] = name.split(':');

                            if (!Store[component]?.[demo]) return null;

                            filePath = Store[component][demo].filePath;
                        } else {
                            if (!Store[name]) return null;

                            filePath = Store[name].filePath;
                        }

                        if (!filePath) return null;

                        if (!hideCode) {
                            try {
                                const source = fs.readFileSync(filePath, 'utf8');

                                node.children?.push(
                                    u('element', {
                                        tagName: 'pre',
                                        properties: {
                                            __src__: filePath,
                                            __spec__: 'DocComponentViewer'
                                        },
                                        children: [
                                            u('element', {
                                                tagName: 'code',
                                                properties: {
                                                    className: ['language-tsx']
                                                },
                                                children: [
                                                    {
                                                        type: 'text',
                                                        value: source
                                                    }
                                                ]
                                            })
                                        ]
                                    })
                                );
                            } catch (error) {
                                // eslint-disable-next-line no-console
                                console.error(`Error reading file ${filePath}:`, error);
                            }
                        }
                    }
                });
            },
            () => (tree) => {
                visit(tree, (node) => {
                    if (node?.type === 'element' && node?.tagName === 'pre') {
                        const [codeEl] = node.children;

                        if (codeEl.tagName !== 'code') {
                            return;
                        }

                        if (codeEl.data?.meta) {
                            // Extract event from meta and pass it down the tree.
                            const regex = /event="([^"]*)"/;
                            const match = codeEl.data?.meta.match(regex);

                            if (match) {
                                node.__event__ = match ? match[1] : null;
                                codeEl.data.meta = codeEl.data.meta.replace(regex, '');
                            }
                        }

                        node.__rawString__ = codeEl.children?.[0].value;
                        node.__src__ = node.properties?.__src__;
                        node.__style__ = node.properties?.__style__;
                        node.__spec__ = node.properties?.__spec__;
                    }
                });
            },
            [
                rehypePrettyCode,
                {
                    theme: 'github-dark-default'
                }
            ],
            () => (tree) => {
                visit(tree, (node) => {
                    if (node?.type === 'element' && node?.tagName === 'figure') {
                        if (!('data-rehype-pretty-code-figure' in node.properties)) {
                            return;
                        }

                        const preElement = node.children.at(-1);

                        if (preElement.tagName !== 'pre') {
                            return;
                        }

                        preElement.properties['__withMeta__'] = node.children.at(0).tagName === 'div';
                        preElement.properties['__rawString__'] = node.__rawString__;
                        preElement.properties['__spec__'] = node?.__spec__ ?? null;

                        if (node.__src__) {
                            preElement.properties['__src__'] = node.__src__;
                        }

                        if (node.__event__) {
                            preElement.properties['__event__'] = node.__event__;
                        }

                        if (node.__style__) {
                            preElement.properties['__style__'] = node.__style__;
                        }

                        const codeElement = preElement.children.at(-1);

                        if (codeElement.tagName !== 'code') {
                            return;
                        }

                        codeElement.properties['className'] = ['language-tsx'];
                    }
                });
            },
            [
                rehypeAutolinkHeadings,
                {
                    behavior: 'append',
                    content: () => h('span', { class: 'ml-4 opacity-0 group-hover:opacity-50 hover:opacity-100 transition-opacity duration-150' }, '#')
                }
            ]
        ]
    }
});

function getNodeAttributeByName(node, name) {
    return node.attributes?.find((attribute) => attribute.name === name);
}

function replaceComponentViewer(content) {
    const matches = content.match(/<DocComponentViewer\s+name=\\?"([^"]+)\\?"[^>]*\/>/g);

    if (!matches) return content;

    for (const match of matches) {
        try {
            const nameMatch = match.match(/name=\\?"([^"]+)\\?"/);

            if (!nameMatch) continue;

            const [component, demo] = nameMatch[1].split(':');

            if (!Store[component]?.[demo]) continue;

            const filePath = Store[component][demo].filePath;
            const source = fs.readFileSync(filePath, 'utf8');

            content = content.replace(match, `\`\`\`tsx\n${source}\n\`\`\``);
        } catch (e) {
            // eslint-disable-next-line no-console
            console.error(e);
        }
    }

    return content;
}

function replaceApiTable(content) {
    const matches = content.match(/<DocApiTable\s+name=\\?"([^"]+)\\?"[^>]*\/>/g);

    if (!matches) return content;

    for (const match of matches) {
        const nameMatch = match.match(/name=\\?"([^"]+)\\?"/);
        const typeMatch = match.match(/type=\\?"([^"]+)\\?"/);

        if (!nameMatch || !typeMatch) continue;

        let data = [];

        switch (typeMatch[1]) {
            case 'token':
                data = getTokenOptions(nameMatch[1]);
                break;
            case 'pt':
                data = getPTOptions(nameMatch[1]);
                break;
            case 'style':
                data = getStyleOptions(nameMatch[1]);
                break;
            default:
                continue;
        }

        if (data[0]?.data) {
            data = data[0].data;
        }

        if (!data.length) continue;

        const headers = Object.keys(data[0]).filter((header) => !['readonly', 'optional', 'deprecated'].includes(header));

        // Capitalize headers and create table header
        let mdxTable = '| ' + headers.map((h) => h.charAt(0).toUpperCase() + h.slice(1)).join(' | ') + ' |\n';

        mdxTable += '|:' + headers.map(() => '------').join('|:') + '|\n';

        data.forEach((prop) => {
            const row = headers.map((header) => {
                let value = prop[header];

                if (header === 'type') {
                    value = value
                        .split('|')
                        .map((t) => t.trim())
                        .join(' \\| ');
                } else if (header === 'options') {
                    if (Array.isArray(value)) {
                        value = value.map((opt) => `${opt.name}: ${opt.type}`).join(', ');
                    }
                } else if (header === 'parameters') {
                    if (value.name && value.type) {
                        value = `${value.name}: ${value.type}`;
                    }
                } else if (header === 'default') {
                    value = value === '' || value === undefined ? 'null' : value;
                }

                return (value || '').toString().replace(/\|/g, '\\|');
            });

            mdxTable += '| ' + row.join(' | ') + ' |\n';
        });

        content = content.replace(match, mdxTable);
    }

    return content;
}
