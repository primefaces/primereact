import { getHighlighter } from '@shikijs/compat';
import { defineDocumentType, makeSource } from 'contentlayer2/source-files';
import fs from 'fs';
import rehypePrettyCode from 'rehype-pretty-code';
import rehypeSlug from 'rehype-slug';
import { codeImport } from 'remark-code-import';
import remarkGfm from 'remark-gfm';
import { u } from 'unist-builder';
import { visit } from 'unist-util-visit';
import { Store } from './__store__/index.mjs';

export const Docs = defineDocumentType(() => ({
    name: 'Docs',
    filePathPattern: 'docs/components/**/*.mdx',
    contentType: 'mdx',
    fields: {
        title: { type: 'string', required: true },
        description: { type: 'string', required: true },
        component: { type: 'string', required: false },
        styles: { type: 'list', of: { type: 'string' }, required: false },
        tokens: { type: 'list', of: { type: 'string' }, required: false },
        pts: { type: 'list', of: { type: 'string' }, required: false },
        autoGenerated: { type: 'boolean', required: false },
        lastUpdated: { type: 'date', required: false }
    },
    computedFields: {
        slug: {
            type: 'string',
            resolve: (doc) => {
                return `/${doc._raw.flattenedPath.includes('features') ? doc._raw.sourceFileDir : doc._raw.flattenedPath}`;
            }
        },
        componentSlug: {
            type: 'string',
            resolve: (doc) => {
                return `${(doc._raw.flattenedPath.includes('features') ? doc._raw.sourceFileDir : doc._raw.flattenedPath).split('/').slice(1).join('/')}`;
            }
        }
    }
}));

export default makeSource({
    contentDirPath: './content',
    documentTypes: [Docs],
    mdx: {
        remarkPlugins: [remarkGfm, codeImport],
        rehypePlugins: [
            rehypeSlug,
            () => (tree) => {
                visit(tree, (node) => {
                    if (node.name === 'DocComponentViewer') {
                        const name = getNodeAttributeByName(node, 'name')?.value;

                        if (!name) {
                            return null;
                        }

                        let filePath;

                        if (name.includes(':')) {
                            const [component, demo] = name.split(':');

                            if (!Store[component]?.[demo]) return null;

                            filePath = Store[component][demo].filePath;
                        } else {
                            if (!Store[name]) return null;

                            filePath = Store[name].filePath;
                        }

                        if (!filePath) return null;

                        try {
                            const source = fs.readFileSync(filePath, 'utf8');

                            node.children?.push(
                                u('element', {
                                    tagName: 'pre',
                                    properties: {
                                        __src__: filePath
                                    },
                                    children: [
                                        u('element', {
                                            tagName: 'code',
                                            properties: {
                                                className: ['language-tsx']
                                            },
                                            children: [
                                                {
                                                    type: 'text',
                                                    value: source
                                                }
                                            ]
                                        })
                                    ]
                                })
                            );
                        } catch (error) {
                            // eslint-disable-next-line no-console
                            console.error(`Error reading file ${filePath}:`, error);
                        }
                    }
                });
            },
            () => (tree) => {
                visit(tree, (node) => {
                    if (node?.type === 'element' && node?.tagName === 'pre') {
                        const [codeEl] = node.children;

                        if (codeEl.tagName !== 'code') {
                            return;
                        }

                        if (codeEl.data?.meta) {
                            const regex = /event="([^"]*)"/;
                            const match = codeEl.data?.meta.match(regex);

                            if (match) {
                                node.__event__ = match ? match[1] : null;
                                codeEl.data.meta = codeEl.data.meta.replace(regex, '');
                            }
                        }

                        node.__rawString__ = codeEl.children?.[0].value;
                        node.__src__ = node.properties?.__src__;
                        node.__style__ = node.properties?.__style__;
                    }
                });
            },
            [
                rehypePrettyCode,
                {
                    theme: 'github-dark-default',
                    getHighlighter,
                    onVisitLine(node) {
                        if (node.children.length === 0) {
                            node.children = [{ type: 'text', value: ' ' }];
                        }
                    },
                    onVisitHighlightedLine(node) {
                        node.properties.className.push('line--highlighted');
                    },
                    onVisitHighlightedWord(node) {
                        node.properties.className = ['word--highlighted'];
                    }
                }
            ],
            () => (tree) => {
                visit(tree, (node) => {
                    if (node?.type === 'element' && node?.tagName === 'figure') {
                        if (!('data-rehype-pretty-code-figure' in node.properties)) {
                            return;
                        }

                        const preElement = node.children.at(-1);

                        if (preElement.tagName !== 'pre') {
                            return;
                        }

                        preElement.properties['__withMeta__'] = node.children.at(0).tagName === 'div';
                        preElement.properties['__rawString__'] = node.__rawString__;

                        if (node.__src__) {
                            preElement.properties['__src__'] = node.__src__;
                        }

                        if (node.__event__) {
                            preElement.properties['__event__'] = node.__event__;
                        }

                        if (node.__style__) {
                            preElement.properties['__style__'] = node.__style__;
                        }
                    }
                });
            }
        ]
    }
});

function getNodeAttributeByName(node, name) {
    return node.attributes?.find((attribute) => attribute.name === name);
}
