import { readFile, writeFile } from 'fs/promises';
import { glob } from 'glob';
import matter from 'gray-matter';
import path from 'path';
import { Store } from '../__store__/index.mjs';
import o from '../data/tokens.mjs';

let APIDocs;

async function loadAPIDocs() {
    const apiJsonPath = path.join(process.cwd(), 'data', 'api.json');
    const apiJsonContent = await readFile(apiJsonPath, 'utf8');
    APIDocs = JSON.parse(apiJsonContent);
}

const autoGeneratedComment = `{/* 
****************************************************************************
****************** PrimeReact MDX Content (Auto-Generated) ******************
*****************************************************************************/
}`;

async function readPropsFromFeatures(componentDir, propName) {
    try {
        const featuresPath = path.join(componentDir, 'features.mdx');
        const content = await readFile(featuresPath, 'utf8');

        // Parse frontmatter using gray-matter
        const { data } = matter(content);
        // Get tokens from frontmatter
        const props = data?.[propName] || [];
        return Array.isArray(props) ? props : [props];
    } catch (error) {
        console.error(`Error reading features.mdx for ${componentDir}:`, error);
        return null;
    }
}

async function generateThemingMdx(componentDir) {
    const componentName = path.basename(componentDir);
    // Get tokens list from features.mdx
    const tokensList = await readPropsFromFeatures(componentDir, 'tokens');
    const stylesList = await readPropsFromFeatures(componentDir, 'styles');
    if (!tokensList || !stylesList) {
        console.log(`No tokens or styles found in features.mdx for ${componentName}`);
        return;
    }
    const themingPath = path.join(componentDir, 'theming.mdx');

    const content = [
        '---',
        `title: '${componentName.charAt(0).toUpperCase() + componentName.slice(1)} Theming'`,
        `description: 'Theming documentation for ${componentName} component'`,
        `component: '${componentName}'`,
        'autoGenerated: true',
        `lastUpdated: '${new Date().toISOString()}'`,
        '---',
        '',
        autoGeneratedComment,
        ''
    ];
    if (stylesList.length > 0) {
        content.push('## Styled');
        stylesList.forEach((style) => {
            content.push(`### ${style} CSS Classes`, '', 'List of class names used in the styled mode.', '', '| Class | Description |', '|:------|:------------|');
            const styleOptions = getStyleOptions(style);
            styleOptions.forEach((styleOption) => {
                content.push(`| **${styleOption.class}** | ${styleOption.description} |`);
            });
        });
    }
    if (tokensList.length > 0) {
        content.push('', '### Design Tokens', '', 'List of design tokens.', '', '| Token | Value | Description |', '|:------|:------|:------------|');

        tokensList.forEach((token) => {
            const tokenOptions = getTokenOptions(token);
            tokenOptions.forEach((tokenOption) => {
                content.push(`| **${tokenOption.token}** | ${tokenOption['CSS Variable']} | ${tokenOption.description} |`);
            });
        });
    }
    content.push(
        '',
        '## Unstyled',
        '',
        'Theming is implemented with the pass through properties in unstyled mode.',
        '',
        '### Tailwind',
        '',
        'Visit [Tailwind Presets](https://github.com/primefaces/primevue-tailwind) project for detailed documentation, examples and ready-to-use presets about how to style PrimeVue components with Tailwind CSS.'
    );
    try {
        await writeFile(themingPath, content.join('\n') + '\n', 'utf8');
        console.log(`✅ Generated theming.mdx for ${componentName}`);
    } catch (error) {
        console.error(`Error generating theming.mdx for ${componentName}:`, error);
    }
}

async function generatePtMdx(componentDir) {
    const componentName = path.basename(componentDir);
    // Get tokens list from features.mdx
    const ptsList = await readPropsFromFeatures(componentDir, 'pts');
    if (!ptsList) {
        console.log(`No pts found in features.mdx for ${componentName}`);
        return;
    }
    const ptPath = path.join(componentDir, 'pt.mdx');

    const content = [
        '---',
        `title: '${componentName.charAt(0).toUpperCase() + componentName.slice(1)} Pass Through'`,
        `description: 'Pass Through documentation for ${componentName} component'`,
        `component: '${componentName}'`,
        'autoGenerated: true',
        `lastUpdated: '${new Date().toISOString()}'`,
        '---',
        '',
        autoGeneratedComment,
        ''
    ];

    if (Store?.[componentName + '-pt']) {
        content.push(
            '',
            '## Viewer',
            '',
            'Some sections may not be visible due to the availability of the particular feature. Section names that start with the pc prefix indicate that the element is a PrimeVue component not a DOM element. Visit the [pass-through](https://primevue.org/passthrough/#pcprefix) documentation for more information.',
            '',
            `<DocPTViewer name="${componentName}-pt" />`,
            ''
        );
    }

    ptsList.forEach((option) => {
        const ptOption = getPTOptions(option);
        content.push(`## ${option} PT Options`, '', '| Value | Label | Options | Description |', '|:------|:------|:--------|:------------|');
        ptOption.forEach((opt) => {
            if (opt.options) {
                const optionsString = opt.options
                    .map((o) => {
                        const type = o.type.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\|/g, '&#124;');
                        return `${o.name}: ${type}`;
                    })
                    .join('<br/>');
                content.push(`| **${opt.value}** | **${opt.label}** | ${optionsString} | ${opt.description || ''} |`);
            } else {
                content.push(`| **${opt.value}** | **${opt.label}** | - | ${opt.description || ''} |`);
            }
        });
    });

    try {
        await writeFile(ptPath, content.join('\n') + '\n', 'utf8');
        console.log(`✅ Generated pt.mdx for ${componentName}`);
    } catch (error) {
        console.error(`Error generating pt.mdx for ${componentName}:`, error);
    }
}

async function generateDocs() {
    try {
        // Load API docs first
        await loadAPIDocs();

        // Get all component directories
        const componentDirs = await glob('content/docs/components/*');

        for (const componentDir of componentDirs) {
            const componentName = path.basename(componentDir);
            console.log(`Processing ${componentName}...`);

            // Generate theming.mdx
            await generateThemingMdx(componentDir);
            // Generate pt.mdx
            await generatePtMdx(componentDir);
        }
    } catch (error) {
        console.error('Error generating docs:', error);
        process.exit(1);
    }
}

// Run the script
generateDocs();

export const getPTOptions = (name) => {
    const { props } = APIDocs[name.toLowerCase()].interfaces.values[`${name}PassThroughOptions`] || APIDocs[name.toLowerCase()].interfaces.values[`${name}DirectivePassThroughOptions`];
    const options = APIDocs[name.toLowerCase()].interfaces.values[`${name}PassThroughMethodOptions`];
    let data = [];

    for (const [i, prop] of props.entries()) {
        if (options) {
            let subCompName, subOptions;
            let hasSubComp = prop.name !== 'hooks' && prop.type.indexOf('TransitionType') === -1 && prop.type.indexOf('<') > -1 && name.toLowerCase() !== prop.type.slice(0, prop.type.indexOf('<')).toLowerCase();

            if (hasSubComp) {
                subCompName = prop.type.slice(0, prop.type.indexOf('<')).replace('PassThroughOptions', '').replace('PassThroughOptionType', '');
                subOptions = APIDocs[subCompName.toLowerCase()].interfaces.values[`${subCompName}PassThroughMethodOptions`];
                const objToReplace = subOptions.props.find((opt) => opt.name === 'parent');

                objToReplace.type = prop.type;
            }

            if (!prop.deprecated) {
                data.push({
                    value: i + 1,
                    label: prop.name,
                    options: hasSubComp ? subOptions?.props : options?.props,
                    description: prop.description
                });
            }
        } else {
            data.push({
                value: i + 1,
                label: prop.name,
                description: prop.description
            });
        }
    }

    return data;
};

export const getStyleOptions = (name) => {
    const styleDoc = APIDocs[name.toLowerCase() + 'style'];
    const enumValues = styleDoc && styleDoc.enumerations && styleDoc.enumerations.values;
    const { members = [] } = enumValues ? enumValues[`${name}Classes`] || {} : {};
    let data = [];

    for (const member of members) {
        const { value, description } = member;

        data.push({
            class: value.replaceAll('"', ''),
            description
        });
    }

    return data;
};

export const getTokenOptions = (name) => {
    let data = [];

    if (o[name.toLowerCase()]) {
        const tokens = o[name.toLowerCase()].tokens;

        for (const [, value] of Object.entries(tokens)) {
            data.push({
                token: value.token,
                /*property: value.name.split('.').slice(1).join('.'),*/
                'CSS Variable': value.variable,
                description: value.description
            });
        }
    }

    return data;
};
